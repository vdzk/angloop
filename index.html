<html>
  <head>
    <title>
      Angloop!
    </title>
    <style>
      svg {
        padding: 3px;
      }
      .cont {
        display: inline-block;
      }
    </style>
  </head>
  <body>
    <div id="svgs"></div>
    <script>
      const minSupply = 14
      const maxSupply = 15
      const sides = 5

      let size = 128
      function draw({loops, sides, commands}) {
        const turn = (loops * Math.PI * 2) / sides  //In radians
        let angle = turn
        let lastPoint = {x: 0, y: 0}
        const points = [{x: 0, y: 0}]
        for (let s = 0; s < sides; s++) {
          [...commands].forEach(c => {
            if (c === 'F') {
              const {x, y} = lastPoint
              const dx = Math.cos(angle)
              const dy = Math.sin(angle)
              const nextPoint = {
                x: x + dx,
                y: y + dy,
              }
              points.push(nextPoint)
              lastPoint = nextPoint
            } else if (c === 'R') {
              angle += turn
            } else if (c === 'L') {
              angle -= turn
            }
          })
        }
        let minX = 0
        let minY = 0
        let maxX = 0
        let maxY = 0
        points.forEach(point => {
          const {x, y} = point
          minX = Math.min(minX, x)
          minY = Math.min(minY, y)
          maxX = Math.max(maxX, x)
          maxY = Math.max(maxY, y)
        })
        const length = maxX - minX
        const height = maxY - minY
        const scale = size / Math.max(length, height)
        points.forEach(point => {
          const {x, y} = point
          point.x = (x - minX) * scale + 1
          point.y = (y - minY) * scale + 1
        })
        const svgEl = document.createElementNS("http://www.w3.org/2000/svg", "svg")
        svgEl.setAttribute('width', size+2+'px')
        svgEl.setAttribute('height', size+2+'px')
        for (let i = 0; i < points.length - 1; i++) {
          //TODO: Create a single curve instead
          const lineEl = document.createElementNS('http://www.w3.org/2000/svg','line');
          lineEl.setAttribute('x1', points[i].x);
          lineEl.setAttribute('y1', points[i].y);
          lineEl.setAttribute('x2', points[i+1].x);
          lineEl.setAttribute('y2', points[i+1].y);
          lineEl.setAttribute("stroke", "black")
          svgEl.append(lineEl);
        }
        const contEl = document.createElement('div')
        contEl.classList.add('cont')
        contEl.setAttribute('title', (sides / loops)+commands)
        contEl.append(svgEl)
        document.getElementById('svgs').append(contEl)
      }

      //Check if the repeating moves forward can be simplified.
      function uniqueForward(commands) {
        let fs = [0]
        for (const move of commands) {
          if (move === 'F') {
            fs[fs.length - 1]++
          } else {
            fs.push(0)
          }
        }
        //Case where start and end is an 'F'
        fs[0] += fs[fs.length - 1]
        fs.splice(-1,1)
        fs = fs.filter(n => n !== 0)
        const min = Math.min( ...fs )
        if (min > 1) {
          for (let d = 2; d <= min; d++) {
            const canDivide = fs.every(n => (n % d) === 0)
            if (canDivide) {
              return false
            }
          }
        }
        return true
      }

      //A set of paterns that should be ignored to avoid repeats
      const ignore = new Set()
      function shouldIgnore({loops, sides, commands}) {
        const arc = loops / sides
        const normalised = []
        //We assume that the first move is Forward and hence there the is no continous turn on each end of the commands
        let lastArc = null
        const precision = 6
        for (const move of commands) {
          if (move === 'F') {
            normalised.push('F')
            lastArc = null
          } else {
            const thisArc = (move === 'R') ? arc : 1 - arc
            if (lastArc === null) {
              normalised.push(thisArc)
              lastArc = thisArc
            } else {
              const totalArc = lastArc + thisArc
              //Avoid useless spins
              if ((totalArc % 1).toFixed(precision) === (0).toFixed(precision)) {
                return true
              } else {
                lastArc = totalArc
                normalised[normalised.length - 1] = totalArc
              }
            }
          }
        }
        const strings = normalised
          .map((move) => {
            if (move === 'F') {
              return 'F'
            } else {
              const arc = move
              return (arc % 1).toFixed(precision)
            }
          })
          .filter((move) => move !== (0).toFixed(precision))

        //Check if this patter exists
        const pattern = strings.join('')
        if (ignore.has(pattern)) {
          return true
        } else {
          //Avoid in-out symmetry
          const outStrings = strings.map((move) => {
            if (move === 'F') {
              return 'F'
            } else {
              return (1 - move).toFixed(precision)
            }
          })
          if (ignore.has(outStrings.join(''))) {
            return true
          } else {
            //Record this and all derrivative patterns
            let variations = strings.slice()
            // console.log((sides / loops)+commands, variations.join(''))
            //Capture repeating patterns
            while (variations.length <= maxSupply + 1) {
              //Capture rotating patterns
              for (let i = 0; i < strings.length; i++) {
                ignore.add(variations.join(''))
                //Capture dirrectional symmetry
                ignore.add(variations.slice().reverse().join(''))
                const head = variations.shift()
                variations.push(head)
              }
              variations = variations.concat(strings)
            }
          }
          return false
        }
      }


      function interesting({loops, sides, commands}) {
        // if (sides !== 5) {
        //   return false
        // }

        if (!uniqueForward(commands)) {
          return false
        }

        let totalTurn = 0
        for (const move of commands) {
          if (move === 'L') {
            totalTurn--
          } else if ( move === 'R') {
            totalTurn++
          }
        }
        //Ignore straight lines
        if (totalTurn === 0) {
          return false
        }
        //Avoid left-right symmetry
        if (totalTurn < 0) {
          return false
        }

        //Ignore boring arcs
        const arc = loops / sides
        if (arc === 1/2 || arc === 1 || arc > 1) {
          return false
        }
        const totalArc = totalTurn * arc
        if (totalArc === 1/2 || totalArc === 1 || totalArc > 1) {
          return false
        }

        if (shouldIgnore({loops, sides, commands})) {
          return false
        }

        return true
      }

      const moves = ['F', 'R', 'L']
      function recMove(config, commandsSupply) {
        if (commandsSupply === 0) {
          if (interesting(config)) {
            draw(config)
          }
        } else {
          for (const move of moves) {
            //Ignore pointless reverse turns
            const prevMove = config.commands[config.commands.length - 1]
            if (!(
                (move === 'L' && prevMove === 'R')
                || (move === 'R' && prevMove === 'L')
            )) {
              recMove(
                {...config, commands: config.commands + move},
                commandsSupply - 1
              )
            }
          }
        }
      }

      for (let supply = minSupply; supply < maxSupply; supply++) {
        for (
          let loopsSupply = 0;
          (loopsSupply + 1) < Math.min(sides, supply);
          loopsSupply++
        ) {
          const commandsSupply = supply - loopsSupply
          const newConfig = {
            loops: 1 + loopsSupply,
            sides,
            commands: 'F'
          }
          recMove(newConfig, commandsSupply)
        }
      }
    </script>
  </body>
</html>
